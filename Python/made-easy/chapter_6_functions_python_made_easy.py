"""Глава 6."""

# # Функции

# В **Python** функция - это группа связанных операторов, выполняющих определен­ ную задачу.
#
# С помощью функций можно разбить программу на более мелкие части.
#
# По мере того как наша программа становится все больше и больше, функции становятся все более и более необходимы для поддержания организованности и управляемости кода.
#
# Как и все остальное в Python, функции тоже являются объектами.
# В функцию можно передавать данные, называемые параметрами. Функция может возвращать данные как результат своей работы. Чтобы вызвать функцию, нужно указать имя функции, за которым следуют круглые скобки () с параметрами. На­пример, функция len(х) возвращает длину параметра х.
#
# # Типы функций
#
# Функции бывают двух типов.
#
# ♦ Встроенные функции уже определены в Python и могут быть вызваны напря­мую.
#
# ♦ Пользовательские функции - это объекты, которые создаются пользователем с помощью явного определения. Функция вызывается с тем же количеством ар­гументов, что и в формальном описании функции.
#
# **Встроенные функции**
#
# ♦ any(iterable) возвращает True, если какой-либо элемент переданной последова­тельности истинен. Если итерируемый объект пуст, возвращается False.
#
# ♦ chr(i) возвращает строку, представляющую собой символ, кодировка которого в таблице Unicode равна i. Например, chr(97) возвращает строку 'а', а chr(8364) возвраащает строку ' € '. Функция обратна функции ord().
#
# ♦ dir([oЬject]) при вызове без аргумента возвращает список имен всех локальных объектов. С аргументом возвращает список допустимых атрибутов для передан­ного объекта.
#
# ♦ float([x]) возвращает число с плавающей точкой, полученное из числа или строки х.
#
# ♦ help ([oЬject]) - это вызов встроенной справочной системы (эта функция пред­ назначена для интерактивного использования). При вызове без аргумента на консоли интерпретатора запускается интерактивная справочная система. Если аргумент является строкой, то ищется соответствующее имя модуля, функции, класса, метода, ключевого слова или раздела документации, а на консоли выводится страница справки. Если аргумент является объектом любого другого типа, для этого объекта создается справочная страница.
#
# ♦ id(object) возвращает идентификатор объекта. Это целое число, которое гаран­тированно будет уникальным и постоянным для этого объекта в течение всего его времени жизни. Два объекта с неперекрывающимся временем жизни могут иметь одинаковое значение id(). С точки зрения реализации CPython это адрес объекта в памяти.
#
# ♦ input([prompt]) используется для получения ввода от пользователя. Если передан аргумент, он выводится в стандартный поток вывода без символа новой строки в конце.
#
# ♦ int([x]) возвращает целочисленный объект, сформированный из числа или строки х.
#
# ♦ isinstance(oЬject, classinfo) возвращает True, если аргумент object является эк­земпляром класса classinfo или его подклассом (прямым, косвенным или вирту­альным). Если объект не является объектом данного типа, функция возвращает False.
#
# ♦ len(s) возвращает длину (количество элементов) переданного объекта. В качестве аргумента можно передать последовательность (например, строку, байтовую строку, кортеж, список или диапазон) или коллекцию (словарь, множество или замороженное множество).
#
# ♦ mар(function, iteraЬle[, ...]) возвращает итератор, который применяет передан­ную функцию к каждому элементу переданного итерируемого объекта. Если в функцию map() передается несколько итерируемых аргументов, то указанная функция function() должна принимать такое же количество аргументов и будет применяться к элементам из всех итерируемых аргументов параллельно. При этом итератор остановится, когда дойдет до конца самого короткого из итерируемых объектов.
#
# # Пользовательские функции
#
# Один из самых мощных инструментов большинства языков программирования, который позволяет пользователю писать свои собственные функции.
#
# ♦ Создавая свои функции, программист избавляется от необходимости переписы­вать один и тот же код снова и снова.
# ♦ Лучше разбивать разные действия на отдельные функции, чем писать всю логи­ку в одном месте. Так у программы будет модульная структура. Более мелкие функции могут повторно пригодиться в аналогичных ситуациях. А если вся ло­гика объединена в одной крупной функции, вы не сможете повторно использо­вать какую-то ее часть, придется написать еще один фрагмент кода.
#
# ♦ Разделение кода на функции упрощает разработку и понимание программы. Также, если работа программы может быть разделена на отдельные действия и каждое действие помещено в отдельную функцию, вы можете писать и провторять фрагменты кода независимо друг от друга.
#
# # Создание и вызов функций
#
# Когда мы пишем оператор def, интерпретатор Python понимает, что мы собираемся определить функцию.  «def» - это сокращение от англ. define (определять). Теперь мы должны дать нашей функции уникальное имя. После слова def следует имя функции, затем пара круглых скобок () и двоеточие (:). В следующей строке идет тело функции. Оно начинается с отступа, который сооб­щает Python, что этот блок кода является телом функции. Тело функции - это не что иное, как код, который функция выполняет.
#
#
# **Аргумент** - это значение, которое мы присваиваем параметру при вызове функ­ции.
#
# **Параметр** - это переменная, указанная в скобках в определении функции:
#
# # Варианты передачи аргументов
#
# **Аргументы со значением по умолчанию**
#
# Наиболее полезный вариант - это указать для одного или нескольких аргументов значение по умолчанию. В этом случае функцию можно вызвать с меньшим коли­чеством аргументов, чем в ней определено.
#
#


def my_address(city: str, state: str, country: str = "India") -> str:
    """_summary_.

    Args:
        city (str): _description_
        state (str): _description_
        country (str, optional): _description_. Defaults to "India".

    Returns:
        str: _description_
    """
    return "I live in " + city + ", " + state + ", " + country


my_address("Mumbai", "Maharashtra")


# Значение по умолчанию не означает, что это единственное значение, которое мо­жет принимать данный параметр. Вы можете передать в функцию любое другое значение. То есть если при вызове функции вы не указываете для этого аргумента значение, он принимает значение по умолчанию.
#
# **Произвольное число аргументов(\*args)**
#
# Если вы не знаете, сколько аргументов будет передано в вашу функцию, добавьте перед именем параметра в определении функции символ *.
# Таким образом, функция получит кортеж аргументов и сможет соответственно обращаться к элементам кортежа.
#
# **Именованные аргументы**
#
# В рассмотренных примерах мы видели, что порядок аргументов имеет значение. В Python порядок аргументов должен быть такой же, как у параметров в определении функции.
# Эти аргументы так же можно передавать с помощью синтаксиса key = value. В таком случае порядок не будет иметь значения
#

# ![image.png](attachment:image.png)

# **Произвольное число именованных аргументов(\*\*kwargs)**
#
# Если количество именованных аргументов, передаваемых в вашу функцию, неиз­вестно, вы можете добавить перед именем параметра в определении функции две звездочки **.
# В этом случае ваша функция получит словарь аргументов, из которого сможет получить доступ к его элементам * по именам.
#
# # Генераторы
#
# Генератор - это функция, возвращающая итератор. То есть эти функции генери­руют объект, который можно перебирать в цикле.
# Генератор - это особый класс функций. Вместо того, чтобы возвращать одно зна­чение, функция-генератор возвращает последовательность значений (объект­ итератор). Слово return в таких функциях заменяется на yield.

# # Практическая часть

# 1. Напишите функцию, которая проверяет, является ли год високосным.
#
#
# Первым високосным годом считается 45 год до нашей эры, и согласно юлианскому календарю начиная с 4 года нашей эры все високосные года становятся четными. Високосным считается каждый четвертый год. Давайте напишем программу, лимит которой будет 3000 год.
#
# Исходя из этого, напишем функцию:


def year(num_year: int) -> str:
    """_summary_.

    Args:
        num_year (int): _description_
    """
    if num_year in list(range(4, 3001, 4)):
        return str(num_year) + " является високосным"
    return str(num_year) + " не является високосным"


year(363)


# 2. Напишите функцию f(х), возвращающую простые множители любого числа х(пример простых множителей: 36 - [2, 2, 3, 3],
# 30 - [2, 3, 5])


def prime_factors(number: int) -> list[int]:
    """_summary_.

    Args:
        number (_type_): _description_

    Returns:
        _type_: _description_
    """
    factors = []
    divisor = 2

    while number > 1:
        while number % divisor == 0:
            factors.append(divisor)
            number //= divisor
        divisor += 1

    return factors


prime_factors(12836339)


# 3. Напишите функцию для преобразования температуры из градусов Цельсия в градусы Фаренгейта. Напишите еще одну функцию для обратного преобразо­ вания.
#
#
# C = (F−32) × 5/9
#
# C / 5/9 = F - 32
#
# F = C / 5/9 + 32
#
# F = 9/5 * C + 32


def frg(celsium: float) -> float:
    """_summary_.

    Args:
        Celsium (float): _description_

    Returns:
        float: _description_
    """
    farengate = 1.8 * celsium + 32
    return farengate


frg(36)


def clm(farengate_degree: float) -> float:
    """_summary_.

    Args:
        farengate_degree (float): _description_

    Returns:
        float: _description_
    """
    celsium_degree = (farengate_degree - 32) * 5 / 9
    return celsium_degree


clm(97)


# 4. Напишите функцию для вычисления факториала любого числа.


def factorial(num1: int) -> int:
    """_summary_.

    Args:
        num1 (int): _description_

    Returns:
        int: _description_
    """
    for mult in range(1, num1):
        num1 *= mult
    return num1


factorial(6)


# 5. Напишите функцию преобразования любого числа от 1 до 100 в римское число.

# def roman(num2: int) -> str:
#     """_summary_.
#
#     Args:
#         num2 (int): _description_
#
#     Raises:
#         ValueError: _description_
#
#     Returns:
#         str: _description_
#     """
#     roman_units: dict[int, str] = {
#         0: "",
#         1: "I",
#         2: "II",
#         3: "III",
#         4: "IV",
#         5: "V",
#         6: "VI",
#         7: "VII",
#         8: "VIII",
#         9: "IX",
#     }
#     roman_tens: dict[int, str] = {
#         0: "",
#         1: "X",
#         2: "XX",
#         3: "XXX",
#         4: "XL",
#         5: "L",
#         6: "LX",
#         7: "LXX",
#         8: "LXXX",
#         9: "XC",
#         10: "C",
#     }
#
#     # Проверяем, что число в диапазоне от 1 до 100
#     if num2 < 1 or num2 > 100:
#         raise ValueError("Input must be between 1 and 100")
#
#     tens = num2 // 10
#     units = num2 % 10
#
#     rom = ""
#     rom = roman_tens[tens] + roman_units[units]
#
#     return rom

# +
# tuple(map(roman, range(1, 101)))
# -

# 6. Напишите функцию f (х) , которая возвращает таблицу умножения числа х.


def multiply(num3: int) -> list[int]:
    """_summary_.

    Args:
        num3 (int): _description_

    Returns:
        list[int]: _description_
    """
    fin: list[int] = []
    for number in range(1, 11):
        fin.append(num3 * number)
    return fin


multiply(2)


# 7. Напишите функцию, которая принимает в качестве исходных данных список и возвращает его перевернутый вариант.


def reverse(your_list: list[int]) -> list[int]:
    """_summary_.

    Args:
        your_list (list[any]): _description_

    Returns:
        list[any]: _description_
    """
    return your_list[::-1]


reverse([1, 2, 3, 4, 5])


# 8. Напишите функцию для расчета сложных процентов.


def compound_interest(amount: float, rate: float, years: int) -> str:
    """_summary_.

    Args:
        investment_amount (float): _description_
        rate (float): _description_
        years_amount (int): _description_

    Returns:
        str: _description_
    """
    total_amount = amount * (1 + rate) ** years
    return "total amount: " + str(total_amount)


print(compound_interest(25000, 0.15, 3))


# Напишите функцию f(х), где х - любое 6-значное число, а функция возвращает сумму его цифр.

# Number: int = 895623
# sum_list: list[int] = []
# for Digit in str(Number):
#     sum_list.append(int(Digit))
# sum(sum_list)


def sum_digits(num4: int) -> int:
    """_summary_.

    Args:
        num4 (int): _description_

    Returns:
        _type_: _description_
    """
    sum_list: list[int] = []
    for digit in str(num4):
        sum_list.append(int(digit))
    return sum(sum_list)


sum_digits(253456)


# 10. Напишите функцию, которая проверяет, является ли переданное число про­стым.


def is_simple(num: int) -> bool:
    """_summary_.

    Args:
        num (int): _description_

    Returns:
        bool: _description_
    """
    simple_div: list[int] = []
    for divisor in range(1, num + 1):
        if num % divisor == 0:
            simple_div.append(divisor)
    if simple_div == [1, num]:
        return True
    return False


total = is_simple(2)
total
